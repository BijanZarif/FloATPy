import glob
import numpy

import matplotlib
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

from base_reader import BaseReader

class WchrAsciiReader(BaseReader):
    """
    Class to read in parallel ASCII data generated by the WCHR Regent code
    """

    def __init__(self, filename_prefix):
        """
        Constructor of the WCHR reader class
        """

        self.filename_prefix = filename_prefix
        self.coord_files = glob.glob(filename_prefix + 'coords_*.dat')

        files = glob.glob(filename_prefix + '[0-9]*.dat')

        self.steps = steps = set([])
        self.prow  = 0
        self.pcol  = 0
        for f in files:
            step = int(f[len(filename_prefix):len(filename_prefix)+4])
            if not (step in steps):
                steps.add(step)

            st  = f[len(filename_prefix):]
            ind = st.find('px')
            row = int(st[ind+2:ind+6])
            if row > self.prow:
                self.prow = row
            ind = st.find('pz')
            col = int(st[ind+2:ind+6])
            if col > self.pcol:
                self.pcol = col

        self.prow += 1
        self.pcol += 1

        self.pencil_lo    = numpy.zeros((self.prow,self.pcol,2), dtype=int)  # Lowest global index of proc in x and z respectively
        self.pencil_hi    = numpy.zeros((self.prow,self.pcol,2), dtype=int)  # Highest global index of proc in x and z respectively
        self.domain_size_  = numpy.zeros(3, dtype=int)                        # Domain size in x, y and z respectively

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                f = open(coordfile)

                line = f.readline().split()
                self.pencil_lo[row,col,0] = int(line[0])
                self.pencil_lo[row,col,1] = int(line[2])

                line = f.readline().split()
                self.pencil_hi[row,col,0] = int(line[0]) + 1
                self.pencil_hi[row,col,1] = int(line[2]) + 1

                if self.domain_size_[1] == 0:
                    self.domain_size_[1] = int(line[1]) + 1

                assert(self.domain_size_[1] == (int(line[1]) + 1), "Data is invalid. Unequal domain sized in the y direction for different pencils!")

                f.close()

        self.domain_size_[0] = self.pencil_hi[-1,-1,0]
        self.domain_size_[2] = self.pencil_hi[-1,-1,1]

        # Indices for each variable
        self.inds = {'rho' : 0, 'u' : 1, 'v' : 2, 'w' : 3, 'p' : 4}

        # Step is set to 0 by default
        self.step = 0

    def updateSummary(self, step):
        assert(step in self.steps, "Step to read in is not available in the dataset.")
        self.step = step

    def setSubDomain(self, lo, hi):
        # Check if lo and hi are within the domain bounds first
        for i in range(3):
            if lo[i] < 0 or lo[i] > self.domain_size_[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size')
            if hi[i] < 0 or hi[i] > self.domain_size_[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size')
            if hi[i] < lo[i]:
                raise ValueError('Invalid indices in chunk. Upper bound cannot be smaller than lower bound')

        # Now set the chunk to be used later
        self.chunk = ((lo[0],hi[0]),(lo[1],hi[1]),(lo[2],hi[2]))

    @property
    def domain_size(self):
        return tuple(self.domain_size_)

    @property
    def sub_domain(self):
        lo = (self.chunk[0][0], self.chunk[1][0], self.chunk[2][0])
        hi = (self.chunk[0][1], self.chunk[1][1], self.chunk[2][1])
        return lo, hi

    @property
    def periodic_dimensions(self):
        return (True, True, True)

    @property
    def time(self):
        return 0.

    def readXCoord(self):
        """
        Method to read in the full domain's X coordinates
        """
        self.x_c = numpy.zeros((self.domain_size_[0], self.domain_size_[1], self.domain_size_[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_x = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.x_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_x.reshape((hi[0]-lo[0], self.domain_size_[1], hi[1]-lo[1]), order='F')

        if self.domain_size_[0] > 1:
            self.dx = self.x_c[1,0,0] - self.x_c[0,0,0]
        else:
            self.dx = 1.


    def readYCoord(self):
        """
        Method to read in the full domain's Y coordinates
        """
        self.y_c = numpy.zeros((self.domain_size_[0], self.domain_size_[1], self.domain_size_[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_y = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(1,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.y_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_y.reshape((hi[0]-lo[0], self.domain_size_[1], hi[1]-lo[1]), order='F')

        if self.domain_size_[1] > 1:
            self.dy = self.y_c[0,1,0] - self.y_c[0,0,0]
        else:
            self.dy = 1.


    def readZCoord(self):
        """
        Method to read in the full domain's Z coordinates
        """
        self.z_c = numpy.zeros((self.domain_size_[0], self.domain_size_[1], self.domain_size_[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(2,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.z_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_z.reshape((hi[0]-lo[0], self.domain_size_[1], hi[1]-lo[1]), order='F')

        if self.domain_size_[2] > 1:
            self.dz = self.z_c[0,0,1] - self.z_c[0,0,0]
        else:
            self.dz = 1.

    def readCoordinates(self):
        """
        Method to read in the X, Y and Z coordinates of a chunk of index values
        """

        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        x_c = numpy.zeros( chunk_size )
        y_c = numpy.zeros( chunk_size )
        z_c = numpy.zeros( chunk_size )

        ny = self.domain_size_[1]

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]

                # Skip this proc if it's lowest dimension is higher than max of chunk
                if ( lo[0] >= self.chunk[0][1] or 0 >= self.chunk[1][1] or lo[1] >= self.chunk[2][1] ):
                    continue
                if ( hi[0] <  self.chunk[0][0] or ny < self.chunk[1][0] or hi[1] <  self.chunk[2][0] ):
                    continue

                # Read in proc's data if there is an overlap
                this_x, this_y, this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,1,2))
                this_x = this_x.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_y = this_y.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_z = this_z.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')

                # Copy data into chunk arrays
                x_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_x[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

                y_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_y[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

                z_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_z[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

        return x_c, y_c, z_c


    def readData(self, var_names):
        """
        Method to read in the a chunk of the data for variables at vizdump step
        """

        # If a simple string is passed in, convert to a tuple
        if isinstance(var_names, basestring):
            var_names = (var_names,)

        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        data = [ numpy.zeros( chunk_size ) for i in range(len(var_names)) ]

        ny = self.domain_size_[1]

        for i in range(len(var_names)):
            var = var_names[i]
            v   = data[i]

            ind = self.inds[var]

            for row in range(self.prow):
                for col in range(self.pcol):
                    filename = self.filename_prefix + ('%04d_px%04d_pz%04d.dat' % (self.step, row, col))
                    lo = self.pencil_lo[row,col]
                    hi = self.pencil_hi[row,col]

                    # Skip this proc if it's lowest dimension is higher than max of chunk
                    if ( lo[0] >= self.chunk[0][1] or 0 >= self.chunk[1][1] or lo[1] >= self.chunk[2][1] ):
                        continue
                    if ( hi[0] <  self.chunk[0][0] or ny < self.chunk[1][0] or hi[1] <  self.chunk[2][0] ):
                        continue

                    # Read in proc's data if there is an overlap
                    this_var = numpy.loadtxt(filename, skiprows=2, unpack=True, usecols=(ind,))
                    this_var = this_var.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')

                    # Copy data into chunk arrays
                    v[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                       max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                       max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                    this_var[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                              max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                              max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

        return tuple(data)

    def plotThreeSlice(self, var, index):
        """
        Method to plot variable var on three orthogonal slices intersecting at the given index
        """
        xind = index[0]
        yind = index[1]
        zind = index[2]

        norm = matplotlib.colors.Normalize(vmin=var.min(), vmax=var.max())
        cmap = cm.ScalarMappable(norm=norm, cmap=cm.viridis)
        cmap.set_array(var)

        fig = plt.figure()
        ax = fig.gca(projection='3d')

        surf_x = ax.plot_surface(self.x_c[xind,:,:], self.y_c[xind,:,:], self.z_c[xind,:,:], facecolors=cmap.to_rgba(var[xind,:,:]), linewidth=0)
        surf_y = ax.plot_surface(self.x_c[:,yind,:], self.y_c[:,yind,:], self.z_c[:,yind,:], facecolors=cmap.to_rgba(var[:,yind,:]), linewidth=0)
        surf_z = ax.plot_surface(self.x_c[:,:,zind], self.y_c[:,:,zind], self.z_c[:,:,zind], facecolors=cmap.to_rgba(var[:,:,zind]), linewidth=0)

        fig.colorbar(cmap)
        plt.show()

    def cubeShowSlider(self, cube, axis=2, **kwargs):
        """
        Display a 3d ndarray with a slider to move along the third dimension.
    
        Extra keyword arguments are passed to imshow
        """
        from matplotlib.widgets import Slider, Button, RadioButtons
    
        # check dim
        if not cube.ndim == 3:
            raise ValueError("cube should be an ndarray with ndim == 3")
    
        # generate figure
        fig = plt.figure()
        ax = plt.subplot(111)
        fig.subplots_adjust(left=0.25, bottom=0.25)
    
        # select first image
        s = [slice(0, 1) if i == axis else slice(None) for i in xrange(3)]
        im = cube[s].squeeze().transpose()
    
        # display image
        l = ax.imshow(im, **kwargs)
    
        # define slider
        axcolor = 'lightgoldenrodyellow'
        ax = fig.add_axes([0.25, 0.1, 0.65, 0.03], axisbg=axcolor)
    
        slider = Slider(ax, 'Axis %i index' % axis, 0, cube.shape[axis] - 1,
                        valinit=0, valfmt='%i')
    
        def update(val):
            ind = int(slider.val)
            s = [slice(ind, ind + 1) if i == axis else slice(None)
                     for i in xrange(3)]
            im = cube[s].squeeze()
            l.set_data(im)
            fig.canvas.draw()
    
        slider.on_changed(update)
    
        plt.show()

BaseReader.register(WchrAsciiReader)

if __name__ == '__main__':
    print 'Subclass:', issubclass(WchrAsciiReader, BaseReader)
    print 'Instance:', isinstance(WchrAsciiReader("../tests/test_wchr_ascii_reader_data/WCHR_"), BaseReader)
