import glob
import numpy

import matplotlib
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

class WchrAsciiReader:
    """
    Class to read in parallel ASCII data generated by the WCHR Regent code
    """

    def __init__(self, filename_prefix):
        """
        Constructor of the WCHR reader class
        """

        self.filename_prefix = filename_prefix
        self.coord_files = glob.glob(filename_prefix + 'coords_*.dat')

        files = glob.glob(filename_prefix + '[0-9]*.dat')

        self.steps = steps = set([])
        self.prow  = 0
        self.pcol  = 0
        for f in files:
            step = int(f[len(filename_prefix):len(filename_prefix)+4])
            if not (step in steps):
                steps.add(step)

            st  = f[len(filename_prefix):]
            ind = st.find('px')
            row = int(st[ind+2:ind+6])
            if row > self.prow:
                self.prow = row
            ind = st.find('pz')
            col = int(st[ind+2:ind+6])
            if col > self.pcol:
                self.pcol = col

        self.prow += 1
        self.pcol += 1

        self.pencil_lo    = numpy.zeros((self.prow,self.pcol,2), dtype=int)  # Lowest global index of proc in x and z respectively
        self.pencil_hi    = numpy.zeros((self.prow,self.pcol,2), dtype=int)  # Highest global index of proc in x and z respectively
        self.domain_size  = numpy.zeros(3, dtype=int)                        # Domain size in x, y and z respectively

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                f = open(coordfile)

                line = f.readline().split()
                self.pencil_lo[row,col,0] = int(line[0])
                self.pencil_lo[row,col,1] = int(line[2])

                line = f.readline().split()
                self.pencil_hi[row,col,0] = int(line[0]) + 1
                self.pencil_hi[row,col,1] = int(line[2]) + 1

                if self.domain_size[1] == 0:
                    self.domain_size[1] = int(line[1]) + 1

                assert(self.domain_size[1] == (int(line[1]) + 1), "Data is invalid. Unequal domain sized in the y direction for different pencils!")

                f.close()

        self.domain_size[0] = self.pencil_hi[-1,-1,0]
        self.domain_size[2] = self.pencil_hi[-1,-1,1]

        # Indices for each variable
        self.inds = {'rho' : 0, 'u' : 1, 'v' : 2, 'w' : 3, 'p' : 4}


    def readXCoord(self):
        """
        Method to read in the full domain's X coordinates
        """
        self.x_c = numpy.zeros((self.domain_size[0], self.domain_size[1], self.domain_size[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_x = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.x_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_x.reshape((hi[0]-lo[0], self.domain_size[1], hi[1]-lo[1]), order='F')

        if self.domain_size[0] > 1:
            self.dx = self.x_c[1,0,0] - self.x_c[0,0,0]
        else:
            self.dx = 1.


    def readYCoord(self):
        """
        Method to read in the full domain's Y coordinates
        """
        self.y_c = numpy.zeros((self.domain_size[0], self.domain_size[1], self.domain_size[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_y = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(1,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.y_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_y.reshape((hi[0]-lo[0], self.domain_size[1], hi[1]-lo[1]), order='F')

        if self.domain_size[1] > 1:
            self.dy = self.y_c[0,1,0] - self.y_c[0,0,0]
        else:
            self.dy = 1.


    def readZCoord(self):
        """
        Method to read in the full domain's Z coordinates
        """
        self.z_c = numpy.zeros((self.domain_size[0], self.domain_size[1], self.domain_size[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(2,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.z_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_z.reshape((hi[0]-lo[0], self.domain_size[1], hi[1]-lo[1]), order='F')

        if self.domain_size[2] > 1:
            self.dz = self.z_c[0,0,1] - self.z_c[0,0,0]
        else:
            self.dz = 1.

    def readCoordinates(self, chunk=None):
        """
        Method to read in the X, Y and Z coordinates of a chunk of index values
        """

        if chunk == None:
            chunk = ( (0, self.domain_size[0]), (0, self.domain_size[1]), (0, self.domain_size[1]) )

        # Check if chunk is within the domain bounds first
        for i in range(3):
            if chunk[i][0] < 0 or chunk[i][0] > self.domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size')
            if chunk[i][1] < 0 or chunk[i][1] > self.domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size')
            if chunk[i][1] < chunk[i][0]:
                raise ValueError('Invalid indices in chunk. Upper bound cannot be smaller than lower bound')

        chunk_size = (chunk[0][1]-chunk[0][0], chunk[1][1]-chunk[1][0], chunk[2][1]-chunk[2][0])
        x_c = numpy.zeros( chunk_size )
        y_c = numpy.zeros( chunk_size )
        z_c = numpy.zeros( chunk_size )

        ny = self.domain_size[1]

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]

                # Skip this proc if it's lowest dimension is higher than max of chunk
                if ( lo[0] >= chunk[0][1] or 0 >= chunk[1][1] or lo[1] >= chunk[2][1] ):
                    continue
                if ( hi[0] <  chunk[0][0] or ny < chunk[1][0] or hi[1] <  chunk[2][0] ):
                    continue

                # Read in proc's data if there is an overlap
                this_x, this_y, this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,1,2))
                this_x = this_x.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_y = this_y.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_z = this_z.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')

                # Compute global intersection region
                p_lo = ( max(lo[0], chunk[0][0]), max(0,  chunk[1][0]), max(lo[1], chunk[2][0]) )
                p_hi = ( min(hi[0], chunk[0][1]), min(ny, chunk[1][1]), min(hi[1], chunk[2][1]) )

                # Copy data into chunk arrays
                x_c[ max(0,lo[0]-chunk[0][0]):min(chunk[0][1]-chunk[0][0],hi[0]-chunk[0][0]), 
                     max(0,   0 -chunk[1][0]):min(chunk[1][1]-chunk[1][0],  ny -chunk[1][0]),    
                     max(0,lo[1]-chunk[2][0]):min(chunk[2][1]-chunk[2][0],hi[1]-chunk[2][0]) ] = \
                this_x[ max(0,chunk[0][0]-lo[0]):min(hi[0]-lo[0],chunk[0][1]-lo[0]),
                        max(0,chunk[1][0]- 0   ):min(  ny -  0  ,chunk[1][1]- 0   ),
                        max(0,chunk[2][0]-lo[1]):min(hi[1]-lo[1],chunk[2][1]-lo[1]) ]

                y_c[ max(0,lo[0]-chunk[0][0]):min(chunk[0][1]-chunk[0][0],hi[0]-chunk[0][0]), 
                     max(0,   0 -chunk[1][0]):min(chunk[1][1]-chunk[1][0],  ny -chunk[1][0]),    
                     max(0,lo[1]-chunk[2][0]):min(chunk[2][1]-chunk[2][0],hi[1]-chunk[2][0]) ] = \
                this_y[ max(0,chunk[0][0]-lo[0]):min(hi[0]-lo[0],chunk[0][1]-lo[0]),
                        max(0,chunk[1][0]- 0   ):min(  ny -  0  ,chunk[1][1]- 0   ),
                        max(0,chunk[2][0]-lo[1]):min(hi[1]-lo[1],chunk[2][1]-lo[1]) ]

                z_c[ max(0,lo[0]-chunk[0][0]):min(chunk[0][1]-chunk[0][0],hi[0]-chunk[0][0]), 
                     max(0,   0 -chunk[1][0]):min(chunk[1][1]-chunk[1][0],  ny -chunk[1][0]),    
                     max(0,lo[1]-chunk[2][0]):min(chunk[2][1]-chunk[2][0],hi[1]-chunk[2][0]) ] = \
                this_z[ max(0,chunk[0][0]-lo[0]):min(hi[0]-lo[0],chunk[0][1]-lo[0]),
                        max(0,chunk[1][0]- 0   ):min(  ny -  0  ,chunk[1][1]- 0   ),
                        max(0,chunk[2][0]-lo[1]):min(hi[1]-lo[1],chunk[2][1]-lo[1]) ]

        return x_c, y_c, z_c


    def readVariables(self, variables, step, chunk=None):
        """
        Method to read in the a chunk of the data for variables at vizdump step
        """

        # If a simple string is passed in, convert to a tuple
        if isinstance(variables, basestring):
            variables = (variables,)

        if chunk == None:
            chunk = ( (0, self.domain_size[0]), (0, self.domain_size[1]), (0, self.domain_size[1]) )

        # Check if chunk is within the domain bounds first
        for i in range(3):
            if chunk[i][0] < 0:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size')
            if chunk[i][1] > self.domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size')
            if chunk[i][1] < chunk[i][0]:
                raise ValueError('Invalid indices in chunk. Upper bound cannot be smaller than lower bound')

        chunk_size = (chunk[0][1]-chunk[0][0], chunk[1][1]-chunk[1][0], chunk[2][1]-chunk[2][0])
        data = [ numpy.zeros( chunk_size ) for i in range(len(variables)) ]

        ny = self.domain_size[1]

        assert(step in self.steps, "Step to read in is not available in the dataset.")

        for i in range(len(variables)):
            var = variables[i]
            v   = data[i]

            ind = self.inds[var]

            for row in range(self.prow):
                for col in range(self.pcol):
                    filename = self.filename_prefix + ('%04d_px%04d_pz%04d.dat' % (step, row, col))
                    lo = self.pencil_lo[row,col]
                    hi = self.pencil_hi[row,col]

                    # Skip this proc if it's lowest dimension is higher than max of chunk
                    if ( lo[0] >= chunk[0][1] or 0 >= chunk[1][1] or lo[1] >= chunk[2][1] ):
                        continue
                    if ( hi[0] <  chunk[0][0] or ny < chunk[1][0] or hi[1] <  chunk[2][0] ):
                        continue

                    # Read in proc's data if there is an overlap
                    this_var = numpy.loadtxt(filename, skiprows=2, unpack=True, usecols=(ind,))
                    this_var = this_var.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')

                    # Compute global intersection region
                    p_lo = ( max(lo[0], chunk[0][0]), max(0,  chunk[1][0]), max(lo[1], chunk[2][0]) )
                    p_hi = ( min(hi[0], chunk[0][1]), min(ny, chunk[1][1]), min(hi[1], chunk[2][1]) )

                    # Copy data into chunk arrays
                    v[ max(0,lo[0]-chunk[0][0]):min(chunk[0][1]-chunk[0][0],hi[0]-chunk[0][0]), 
                       max(0,   0 -chunk[1][0]):min(chunk[1][1]-chunk[1][0],  ny -chunk[1][0]),    
                       max(0,lo[1]-chunk[2][0]):min(chunk[2][1]-chunk[2][0],hi[1]-chunk[2][0]) ] = \
                    this_var[ max(0,chunk[0][0]-lo[0]):min(hi[0]-lo[0],chunk[0][1]-lo[0]),
                              max(0,chunk[1][0]- 0   ):min(  ny -  0  ,chunk[1][1]- 0   ),
                              max(0,chunk[2][0]-lo[1]):min(hi[1]-lo[1],chunk[2][1]-lo[1]) ]

        return tuple(data)

    def plotThreeSlice(self, var, index):
        """
        Method to plot variable var on three orthogonal slices intersecting at the given index
        """
        xind = index[0]
        yind = index[1]
        zind = index[2]

        norm = matplotlib.colors.Normalize(vmin=var.min(), vmax=var.max())
        cmap = cm.ScalarMappable(norm=norm, cmap=cm.viridis)
        cmap.set_array(var)

        fig = plt.figure()
        ax = fig.gca(projection='3d')

        surf_x = ax.plot_surface(self.x_c[xind,:,:], self.y_c[xind,:,:], self.z_c[xind,:,:], facecolors=cmap.to_rgba(var[xind,:,:]), linewidth=0)
        surf_y = ax.plot_surface(self.x_c[:,yind,:], self.y_c[:,yind,:], self.z_c[:,yind,:], facecolors=cmap.to_rgba(var[:,yind,:]), linewidth=0)
        surf_z = ax.plot_surface(self.x_c[:,:,zind], self.y_c[:,:,zind], self.z_c[:,:,zind], facecolors=cmap.to_rgba(var[:,:,zind]), linewidth=0)

        fig.colorbar(cmap)
        plt.show()

    def cubeShowSlider(self, cube, axis=2, **kwargs):
        """
        Display a 3d ndarray with a slider to move along the third dimension.
    
        Extra keyword arguments are passed to imshow
        """
        from matplotlib.widgets import Slider, Button, RadioButtons
    
        # check dim
        if not cube.ndim == 3:
            raise ValueError("cube should be an ndarray with ndim == 3")
    
        # generate figure
        fig = plt.figure()
        ax = plt.subplot(111)
        fig.subplots_adjust(left=0.25, bottom=0.25)
    
        # select first image
        s = [slice(0, 1) if i == axis else slice(None) for i in xrange(3)]
        im = cube[s].squeeze().transpose()
    
        # display image
        l = ax.imshow(im, **kwargs)
    
        # define slider
        axcolor = 'lightgoldenrodyellow'
        ax = fig.add_axes([0.25, 0.1, 0.65, 0.03], axisbg=axcolor)
    
        slider = Slider(ax, 'Axis %i index' % axis, 0, cube.shape[axis] - 1,
                        valinit=0, valfmt='%i')
    
        def update(val):
            ind = int(slider.val)
            s = [slice(ind, ind + 1) if i == axis else slice(None)
                     for i in xrange(3)]
            im = cube[s].squeeze()
            l.set_data(im)
            fig.canvas.draw()
    
        slider.on_changed(update)
    
        plt.show()
